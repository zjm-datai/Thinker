在前后端分离的单页应用（SPA Single-Page-Application）中，通常会使用浏览器的 HTML5 History API 也叫 History 模式来实现看起来像传统多页网站的路由体验。

[[HTML5 History API 在 SPA 中的使用]]

>[!note]
> **单页应用和传统多页应用**
>
> 单页应用的特点：整个应用只有一个 HTML 主页面，所有的功能模块和内容都通过 JS 动态渲染到该页面上。在用户操作的时候，页面不会整体进行刷新，而是通过 JS 局部更新 DOM 的内容，实现视图切换，例如点击导航的时候仅仅更新页面的主体部分。数据交互方式也是有不同，单页应用下会通过 API 和后端进行数据交互，前端负责展示和交互逻辑，后端专注于数据处理和接口提供。
> 
>  传统的多页应用 MPA 的特点在于：由多个独立的 HTML 页面构成，每个页面对应不同的功能或内容模块。交互体验：用户点击链接或操作时，浏览器会向服务器请求新的 HTML 页面，导致整个页面刷新，例如传统网站的页面跳转。数据交互方式：页面内容通常在服务器端通过模板引擎（如 JSP、PHP）动态生成，再返回给浏览器。

Vue Router，React Router 等库会根据访问的 URL，比如 `/user/123` ，在客户端解析出要渲染的组件，并不会去服务器请求一个真实存在的 `/user/123` 的目录或是文件。

当用户在浏览器地址栏直接输入或刷新 `/users/123`，浏览器会发起对服务器的请求。服务器（Nginx、Apache、Express、IIS……）默认会去磁盘上找 `/users/123` 这个资源：

- 若不存在，就返回 404；
- 而我们真正想要的，是把所有前端路由都交给同一个入口文件（通常是 `index.html`）来执行客户端路由逻辑。

**“rewrite fallback” 的由来**  

为了解决上述问题，需要在服务器层面做一个“重写（rewrite）”或“回退（fallback）”策略：

- **重写**：把所有不匹配静态资源的请求，都内部重定向（rewrite）到 `/index.html`；
- **回退**：如果找不到对应静态文件，就回退到入口页面。

所以说在使用 history 模式的时候（默认我们的 vue 等前端框架的处理方式），我们的应用需要在服务器层面多做一次进行重写和回退的操作。

在这种情况下，哈希路由就显得很有必要了。

### 为什么哈希路由不需要 rewrite fallback 

- **URL 结构**
    
    - 哈希路由的 URL 会带上 `#`（例如 `https://example.com/#/users/123`）
    - `#` 及其后的部分只在浏览器端使用，不会被发送到服务器

- **服务器视角**
    
    - 当浏览器请求 `https://example.com/` 时，服务器只看到路径 `/`，永远不会去找 `/users/123`
    - 因此，无需配置任何静态文件重写或回退，直接返回同一个入口页即可

- **优点**
    
    - 部署简单，不依赖服务器配置
    - 即便在老旧或受限的托管环境（如 GitHub Pages、某些 CDN）也能稳定工作

### Hash 模式的局限

1. **不美观**
    
    - URL 中带有 `#` 符号，看起来不够“干净”。

2. **SEO 与分享**
    
    - 尽管搜索引擎会抓取 `#` 后的内容（现代搜索引擎基本支持），但有时候在社交分享或第三方工具中可能被忽略或解析异常。

3. **浏览器 API 限制**
    
    - 只能通过监听 `window.onhashchange` 实现路由变化，功能不如 `history.pushState` 丰富（例如无法携带复杂状态对象）。

### History 模式的优势与必要性

- **干净的 URL**
    
    - 例如 `https://example.com/users/123`，与传统 MPA 完全一致。

- **完整的导航体验**
    
    - 支持 `state` 对象、`title` 管理，以及更细粒度的浏览器历史操作控制。

- **SEO 友好**
    
    - 在结合服务端渲染（SSR）或预渲染（Prerender）时，首屏内容可被搜索引擎和社交爬虫正常抓取。

### Python 中的垃圾回收机制

python 使用引用计数为主，标记-清除和分代回收为辅的垃圾回收机制。

如果对象参与了循环引用（A 引用 B，B 又引用 A），单靠引用计数无法清理，这时就要靠分代 GC（即标记-清除）才能回收。但 GC 在处理含有 `__del__` 的循环引用对象时会更谨慎，有时甚至不会自动调用 `__del__`，从而导致内存泄漏。

**所有由 Python 解释器创建和管理的对象**，只要它们**还在内存中存在**，Python 的垃圾回收机制都会“**有能力**”去追踪和回收它们。

详细解释：

- 引用计数 reference counting 

每个对象都有一个引用计数器，计数为 0 的时候会被立即回收

- 循环引用问题

如果两个对象互相引用，即使他们不再被外部访问，引用计数也不会归零 -- 这就导致了内存泄露的风险

- 标记 - 清除（Mark-and-Sweep）

GC 会定期扫描对象图，标记活着的对象，然后清除未被引用的对象

- 分代回收 Generational GC

将对象划分为 3 代（0、1、2），新对象在 0 代，存活时间长的会晋升。
因为大多数对象生命周期很短，所以更频繁地回收 0 代提高效率。

### `__del__` 方法

在 python 中析构方法指的是当对象被销毁时自动调用的方法，用于释放资源（如关闭文件，断开连接等）。

#### 触发时机

当对象的引用计数为 0 时（如变量被删除，函数执行完毕等），python 垃圾回收机制会自动调用 `__del__` 。例如：

```python
class MyClass:
	def __del__(self):
		print("对象被销毁")

obj = MyClass()
del obj
```

资源释放的替代方案：更推荐使用 with 语句（如操作文件，数据库）或 `__exit__` 方法（上下文管理器）来管理资源。

### 什么是内存泄漏？如何避免

内存泄漏指的是程序不再使用某些内存资源，但是这些资源没有被释放，导致系统可用的内存逐渐减少。

常见的内存泄漏场景：

- 循环引用未被及时回收

引用计数机制无法处理**对象之间相互引用**的情况，GC 必须额外介入。

```python
class A:
    def __init__(self):
        self.ref = self

a = A()
del a # 删除 a 对实例的引用
```

表面上 `a` 被删除了，但 `self.ref = self` 是个循环引用，它会让对象的引用计数永远 > 0，**不会立即回收**，直到 GC 定期检查出来。

- 缓存没有清理：比如使用全局字典或 LRU 缓存，元素未过期导致占用内存
- 忘记关闭文件，连接等资源：如 open() 没有关闭，文件描述符泄漏
- 异常导致引用没有被释放

### GC 无法回收哪些对象？

python 的垃圾回收的实现分为两个部分

1. 引用计数（Reference Counting）每个对象维护一个计数器，记录被引用的次数，为 0 的时候立即释放内存
2. 垃圾回收器（gc module / cyclic GC）专门用来清理引用计数无法处理的循环引用（mutual reference）

> 引用计数是实时的，循环垃圾回收是定期触发的。

#### GC 如何进行回收

所有的对象都有引用计数

```python
import sys
a = []
print(sys.getrefcount(a))  # 通常会多 1，因为 getrefcount 也引用了一次
```

- 创建对象时引用计数为 1；
- 被变量引用、传参、赋值都会增加计数；
- 删除引用则减少；
- 当计数变成 0，**对象立即被销毁**。

> 这里要注意的是 a 自己只是一个标识符，引用计数针对的是对象而不是变量名，如果 del a 的话对 [] 的引用就变为 0 了那么这个对象也就清除了。

#### 如何触发 GC

**自动触发（基于阈值）**

python 维护三个计数器 `(threshold0, threshold1, threshold2)`，默认值通常为`(700, 10, 10)`：

- **对象分配次数**：每当创建新对象或删除对象时，计数器 `gc.garbage_allocations` 增加。
- **触发条件**：当 `gc.garbage_allocations - gc.garbage_collections` 超过 `threshold0` 时，触发第 0 代垃圾回收。

**手动触发**

```python
import gc
gc.collect()  # 强制进行一次垃圾回收

gc.get_count()  # 返回三代对象的当前计数
gc.get_threshold()  # 返回三代回收阈值
```

---

**Python 的 GC 管理的是：可变、可能参与循环引用的对象。**

它主要依靠：

1. **引用计数** —— 实时清理；
2. **分代垃圾回收** —— 处理循环引用。

不可变对象（`int`, `str`, `tuple`）和底层资源（如文件描述符、C 数组）**不是 GC 管理的重点**。

#### GC 无法回收哪些对象

1. 对象没有参与垃圾回收的（纯 C 层的对象）

Python 内部的一些对象（如 `int`, `str`, `tuple` 等不可变类型）**不是由 GC 管理的**，它们仅依赖引用计数。

这些对象没有 `__dict__`、没有 `__del__`、不可变、不可循环引用，**不会被垃圾回收器扫描**，只靠引用计数自动清理。

2. 含有 `__del__` 方法的，参与循环引用的对象

这个问题涉及到 Python 垃圾回收机制的一个重要限制：**当循环引用的对象包含自定义的析构函数（`__del__`）时，垃圾回收器无法安全地回收它们**。

**含 `__del__` 的循环引用对象成为 “不可回收的垃圾” 的原因**：

1. **销毁顺序的不确定性**：Python 无法安全地决定先销毁哪个对象。
2. **保守策略**：为避免程序崩溃，GC 选择将这些对象隔离到 `gc.garbage` 中。

这是 Python 在 **内存安全** 和 **程序稳定性** 之间的权衡。理解这一点有助于编写更健壮的代码，避免内存泄漏。

3. C 扩展模块中分配的内存（如 NumPy、Pandas 内部）

```python
import numpy as np
a = np.zeros((1000000,))
```

- 变量 `a` 是 Python 对象，GC 可见；
- 但 `a.data` 是 C 分配的大块内存，**Python GC 无法追踪这一部分内存**；
- 如果对象生命周期太长（比如放在全局变量中），这些 C 层内存就可能 **“看不见地泄漏”**。

---

`__del__` 方法的特殊性

- **`__del__`** 是 Python 对象的析构函数，当对象被垃圾回收时自动调用。
- 它通常用于释放 **非 Python 资源**（如文件句柄、数据库连接、网络套接字等）。

```python
class ResourceManager:
    def __init__(self, name):
        self.name = name
        print(f"资源 {name} 已创建")
    
    def __del__(self):
        print(f"资源 {self.name} 已释放")

r = ResourceManager("文件")
# 当 r 被回收时，__del__ 会自动调用

del r
gc.collect()  # 强制垃圾回收
```

循环引用的本质：  

两个或多个对象通过引用形成闭环（如 a.ref = b 且 b.ref = a）。  
垃圾回收时，需要同时销毁所有参与循环的对象，否则可能导致部分对象的引用计数不为 0。

**del** 导致的销毁顺序问题：  

当对象有 **del** 方法时，Python 无法确定析构的顺序：  
如果先销毁对象 A，A 的 **del** 可能访问 B，但 B 已被销毁。  
如果先销毁 B，B 的 **del** 可能访问 A，但 A 已被销毁。  
这种不确定性可能导致程序崩溃或未定义行为。

Python 的保守策略：  

为了避免上述风险，Python 采取了保守策略：

1. 检测循环引用：当垃圾回收器发现循环引用时，会标记这些对象。
2. 检查 **del** 方法：如果循环中的任何对象有 **del** 方法，垃圾回收器不会尝试回收它们。
3. 移入 gc.garbage：这些对象会被放入 gc.garbage 列表，等待用户手动处理。

```python
import gc

class A:
    def __del__(self):
        print("A 被析构")

a = A()
a.self_ref = a  # 自己引用自己
del a  # 断开外部引用

gc.collect()  # 触发垃圾回收
print(gc.garbage)  # a 会出现在这里，不会被回收
```

你可能会问：**为什么不先断开循环引用，再逐个销毁对象？**

这是因为：

- **`__del__` 可能依赖引用**：对象的析构函数可能需要访问其引用的其他对象。
- **破坏对象完整性**：断开循环引用会破坏对象的内部状态，导致 `__del__` 执行时出现异常。
- **线程安全问题**：在多线程环境中，断开循环引用可能导致竞态条件。

---
##### 为什么不可变对象没有 `__dict__` 对垃圾回收很关键？

这个问题涉及到 Python 内存管理的底层机制，特别是 **不可变对象（如 `int`、`str`、`tuple`）** 与 **可变对象（如 `list`、`dict`、`set`）** 的区别。

**`__dict__` 的作用**

这是一个 python 对象的特殊属性，用于存储对象的所有实例属性。每个对象的 `__dict__` 是一个字典，键为属性名，值为属性值。

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

p = Person("Alice", 30)
print(p.__dict__)  # 输出: {'name': 'Alice', 'age': 30}
```

**不可变对象没有 `__dict__` 的原因**

- 内存效率优化

不可变对象（如 `int`、`str`、`tuple`）的属性是固定的，无需动态添加属性。
如果为每个整数或字符串分配一个 `__dict__` 字典，会导致 **内存浪费**。

- 不可变性保证

不可变对象的属性在创建后不能修改，没有 `__dict__` 可以防止用户通过 `obj.attr = value` 方式破坏其不可变性。

- 性能优化

没有这个属性意味着访问属性的时候不需要哈希表查找，直接通过 C 结构体偏移量进行访问，速度更快。

**为什么这对垃圾回收很关键？**

没有 `__dict__` 就不可能形成循环引用，循环引用的条件是：两个或多个对象之间通过属性相互访问。

不可变对象没有 `__dict__` 这么个字典，就无法存储对其他对象的引用，因此也就不可能参与循环引用。

```python
# 不可变对象无法形成循环引用
a = (1, 2, 3)  # tuple 没有 __dict__，无法引用其他对象
b = (a, 4)     # b 引用 a，但 a 无法反向引用 b
```

简化垃圾回收逻辑

- Python 的垃圾回收器（GC）主要负责检测和回收 **循环引用**。
- 由于不可变对象不会参与循环引用，GC 可以 **跳过对它们的扫描**，只依赖引用计数即可安全回收。

- **引用计数管理**：不可变对象的内存回收完全依赖引用计数，当引用计数为 0 时立即释放。
- **特殊处理**：
    - 小整数（-5 到 256）和短字符串会被缓存重用，不参与垃圾回收。
    - 不可变对象的创建和销毁成本极低，因为不需要 GC 干预。

### GC 是怎么检测出循环引用的对象的？

#### 循环引用的本质

当两个或多个对象互相引用的时候，形成引用环。例如：

```python
a = []
b = []
a.append(b)
b.append(a)
```

此时，即使没有其他变量引用 a 和 b ，他们的引用计数也不会变为 0（因为互相引用），普通引用计数法无法检测到这类对象需要进行回收。

#### GC 检测循环引用的步骤

python 的 GC 模块通过标记-清楚算法处理循环引用，流程如下：

##### 阶段 1 标记所有可达对象

- 从根对象（如全局变量，栈上的变量等）出发，遍历所有可达对象，标记为存活
- 未被标记的对象可能是垃圾（包括循环引用的对象）

##### 阶段 2 检测循环引用并清除

对未标记的对象，检查是否存在循环引用：

- 遍历对象间的引用关系，若发现对象 A 引用对象 B，且 B 也引用 A，且两者均未被标记未存货，则判定为循环引用。
- 若循环引用的对象中没有 `__del__` 方法（避免因为析构顺序问题导致死锁），则清除这些对象的引用，释放内存。

#### 循环引用和 `__del__` 的冲突

如果循环引用的对象定义了 `__del__()` 方法，GC 会将其视为不可回收，导致内存泄漏。因此，python 文档明确建议避免在类中使用 `__del__` ，除非确有必要（如和 C 扩展交互）。





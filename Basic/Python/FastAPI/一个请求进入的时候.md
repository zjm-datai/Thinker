一个请求进入 FastAPI 会经过如下流程进行处理：

多进程架构，Uvicorn 作为 ASGI 服务器，采用主进程和工作流程模型。主进程负责管理一组工作进程（通过 `--workers` 配置），并将接收到的连接分发到各个子进程进行处理。

#### 事件循环线程（uvloop）

每个工作进程内部启动一个单线程 `uvloop` 事件循环，负责网络 I/O（`httptools` 解析 HTTP 报文）、ASGI 消息分发以及调度所有异步任务。所有 `async def` 路由、异步依赖和异步中间件都在这条线程上运行。
##### 事件循环是什么？

事件循环是 Python `asyncio`（及其高性能替代品 `uvloop`）的核心调度器，它运行在**单个线程**上，负责：

- 管理和调度所有的异步任务（协程）。

- 监听网络 I/O、文件 I/O、定时器等操作完成的信号（通过底层的 `epoll`/`kqueue`/IOCP 等机制）。

- 在有任务可以继续执行时，把执行权交给对应的协程。

这意味着，事件循环本质上是一种**协作式多任务**调度：只有在协程遇到 `await`（等待某个 I/O 或其它异步操作）时，才会主动让出执行权给其他任务；否则，它会一直占用这条线程，直到当前协程结束或再次 `await`。

**ASGI 请求-响应周期**  

当事件循环线程接收到完整的 HTTP 请求后，会触发 Starlette 的 `RequestResponseCycle`，将 ASGI `http.request` 事件映射到应用层（`app(scope, receive, send)`），此过程也是在事件循环线程中完成的。

**线程池（Thread Pool）**  

对于同步（`def`）的路由函数、同步依赖、文件操作（`FileResponse`、`UploadFile`）和后台任务，Starlette 会使用 AnyIO/asyncio 提供的线程池（默认允许 40 个并发线程）执行，以避免阻塞事件循环。

**同步代码执行与切换**

执行同步代码时，事件循环线程通过 `anyio.to_thread.run_sync` 或 `fastapi.concurrency.run_in_threadpool` 将任务下发到线程池；线程池线程执行完成后，再切回事件循环线程构造并发送响应。

#### async 路由的处理

**事件循环线程**

对于 async def 声明的异步路径处理函数，其执行和调度主要发生在单线程的事件循环中，用于所有异步任务的调度和 IO 多路复用，异步路由函数在这条线程上执行，不会创建额外的线程。

**协程的创建和切换**

当 HTTP 请求到达的时候，Starlette 在该事件循环线程中为对应的 `async def` 路由函数创建一个协程任务，协程执行到 `await` 时会挂起，立即让出线程给其他就绪任务，待被等待的 I/O 完成后再恢复。整个过程 **完全不离开事件循环线程**。

**高性能非阻塞 IO**

`uvloop` 底层基于 libuv，利用 Linux 的 `epoll` / BSD 的 `kqueue` / Windows 的 IOCP 等机制，统一在单线程中监听和分发网络读写、定时器、信号等事件，确保在 I/O 操作时线程不被阻塞。

**线程池边界**

**只有**普通 `def` 路由函数、同步依赖或显式的阻塞 I/O（例如直接读写文件）才会被 FastAPI/Starlette 自动委派到后台线程池（默认约 40 线程）执行；而所有 `async def` 路由始终在事件循环线程内运行，不走线程池。

**跨核并行**

单个工作进程内的异步任务仍受限于 Python GIL 和单线程事件循环。若需利用多核并行，通常通过 Uvicorn 启动多进程（`--workers`）或配合外部进程/容器编排，实现真正的跨核并行处理。

#### 为什么同步函数会阻塞事件循环

同步函数（`def` 定义的普通函数）在运行时**不会遇到 `await`**，也就不会把控制权还给事件循环；它会**连续、顺序**地执行直到返回结果。

- 在这个过程中，事件循环所在的那条线程被同步代码“霸占”了。

- 既然线程被占用了，事件循环就**无法检测到 I/O 完成**、无法调度其它协程，也就无法响应其它并发请求。

简单来说，同步代码在事件循环线程上执行时，就是在 **“堵塞”** 这条线程，使它不能去做任何别的事。

#### FastAPI 如何兼容同步和异步代码？

为了既能享受异步的高并发优势，又能兼容传统的同步库，FastAPI（底层的 Starlette）在检测到路径操作函数是同步时，会把它**扔到后台的线程池**里执行：

- 默认线程池大小约 40 个线程（可配置）。

- 线程池线程执行完同步函数后，再把结果传回事件循环线程，由它来构造并发送 HTTP 响应。

- 这样即便某个同步路由函数很耗时，也只会占用线程池的一个线程，不会完全卡死事件循环。

但是要注意的是，如果你在异步路由函数中调用非常阻塞的同步函数，那就会卡住事件循环。这里有一个误区就是有人会认为，fastapi 会自动检测出耗时的 io 操作然后让出事件循环，其实是不对的。在 async 路由中，我们进入了事件循环，但是 FastAPI 不会自动检测 I/O 操作并让出事件循环。

在 Python 的异步编程中，让出事件循环是通过 `await` 关键字实现的。当你在异步函数中调用一个异步操作（例如 `await asyncio.sleep(1)`）时，`await` 会暂停当前协程的执行，让出控制权给事件循环，允许事件循环处理其他任务。

如果调用的是同步 I/O 操作，它不会自动让出事件循环，因为同步 I/O 操作是阻塞的。

##### 总结

- FastAPI 本身不会自动检测 I/O 操作并让出事件循环。

- 如果你在异步函数中调用了同步 I/O 操作，需要手动将这些操作放入线程池中，以避免阻塞事件循环。

- 使用 `run_in_threadpool` 或 `asyncio.to_thread` 可以将同步 I/O 操作放入线程池，从而避免阻塞事件循环线程。

### 调优实操

[[Why is my FastAPI throughput so low]]



## 面向开发人员的 HTTPS

### 域名


### DNS

现在让我们关注真正的 HTTPS 部分。

首先，浏览器将通过 **DNS 服务器** 查询**域名的IP** 是什么，在本例中为 `someapp.example.com`。

DNS 服务器会告诉浏览器使用某个特定的 **IP 地址**。 这将是你在 DNS 服务器中为你的服务器配置的公共 IP 地址。

![[Pasted image 20250710163941.png]]

### TLS 握手开始

然后，浏览器将在 **端口 443**（HTTPS 端口）上与该 IP 地址进行通信。

通信的第一部分只是建立客户端和服务器之间的连接并决定它们将使用的加密密钥等。

![[Pasted image 20250710164023.png]]

客户端和服务器之间建立 TLS 连接的过程称为 **TLS 握手**。

### 带有 SNI 扩展的 TLS

在服务器环境中，对于特定的 IP 地址和端口的组合，只能有一个进程进行监听。其他进程可以监听同一个 IP 的其他端口，但是 443 端口（TLS 默认端口）只能被唯一进程占用，该进程也就是 TLS 终止代理。

TLS 终止代理存储着多个 TLS 证书（用于 HTTPS 加密）。当客户端发起连接时，会通过 **SNI 扩展** 告知目标域名（如 `someapp.example.com` ）。代理据此从自身存储的证书中，匹配出对应该域名的证书，用于建立客户端与服务器间的加密通信，完成 TLS 层的解密与加密处理。

![[Pasted image 20250710165052.png]]

客户端（比如你的浏览器）本来就信任颁发这个 TLS 证书的机构（这里是 Let's Encrypt），所以它能判断这个证书是不是真的有效。

接着，客户端和那个 TLS 终止代理（就是守着 443 端口的 “门卫”）会用这个证书商量好，接下来的 TCP 通信该怎么加密。到这儿，TLS 握手这一步就完成了。

之后，客户端和服务器之间就有了一条加密的 TCP 连接，这正是 TLS 起到的作用。然后它们就能用这条加密连接，开始真正的 HTTP 通信了。

所以 HTTPS 其实很简单，就是把普通的 HTTP 放进了安全的 TLS 连接里，而不是像 HTTP 那样直接用没加密的 TCP 连接传输。

>[!Tip]
>请注意，通信加密发生在 **TCP 层**，而不是 HTTP 层。

### HTTPS 请求

现在客户端和服务器（特别是浏览器和 TLS 终止代理）具有 加密的 TCP 连接，它们可以开始 **HTTP 通信**。

接下来，客户端发送一个 HTTPS 请求。 这其实只是一个通过 TLS 加密连接的 HTTP 请求。

![[Pasted image 20250710165712.png]]

### 解析请求

TLS 终止代理将使用协商好的加密算法 **解密请求**，并将 **（解密的）HTTP 请求** 传输到运行应用程序的进程（例如运行 FastAPI 应用的 Uvicorn 进程）。

![[Pasted image 20250710165757.png]]

### HTTP 响应

应用程序将处理请求并向 TLS 终止代理发送 **（未加密）HTTP 响应**。

![[Pasted image 20250710165826.png]]

### HTTPS 响应

然后，TLS 终止代理将使用之前协商的加密算法（以 `someapp.example.com`的证书开头）对响应进行加密，并将其发送回浏览器。

接下来，浏览器将验证响应是否有效和是否使用了正确的加密密钥等。然后它会 **解密响应** 并处理它。

![[Pasted image 20250710165909.png]]

客户端（浏览器）将知道响应来自正确的服务器，因为它使用了他们之前使用 **HTTPS 证书** 协商出的加密算法。

### 多个应用程序

服务器就像一个大办公室，里面能同时坐多个不同的团队（多个应用程序，比如API 服务、数据库等）。 

但办公室对外的大门是有规矩的：

**同一个门口（特定IP+端口）只能有一个团队负责接待**（比如之前说的TLS终止代理守着443端口）。 

其他团队也能在办公室里正常工作，但有个前提：**它们不能去抢别人已经占了的门口**。

比如，TLS 终止代理已经用了 “IP地址1.2.3.4 + 端口443” 这个组合，其他应用就不能再用这个组合对外提供服务了。 但它们可以用其他门口（比如其他端口，或者服务器的其他 IP 地址）。比如： 

- 数据库可以用 “IP 地址 1.2.3.4 + 端口 3306” 
- 另一个API程序可以用 “IP 地址1.2.3.4 + 端口 8080” 
- 甚至可以用服务器的另一个 IP 地址，比如 “ IP地址 5.6.7.8 + 端口 443”（如果服务器有多个 IP 的话） 

这样一来，多个应用程序就能在同一台（或多台）服务器上同时运行，互不冲突，各自通过自己的 “门口” 处理业务。

![[Pasted image 20250710170211.png]]

这样，TLS 终止代理就可以为多个应用程序处理 **多个域名** 的 HTTPS 和证书，然后在每种情况下将请求传输到正确的应用程序。

### 证书更新

每个 TLS 证书都有保质期，大概 3 个月就会过期。过期之后，得有个程序（可能是之前那个 TLS 终止代理，也可能是别的专门程序）去跟 Let's Encrypt 打交道，把证书更新一下。

TLS 证书是跟域名绑在一起的，不是跟 IP 地址绑的。所以要更新证书，负责更新的程序得向 Let's Encrypt 这样的权威机构证明：这个域名确实是自己在管、在控制。

![[Pasted image 20250710170430.png]]

证明的办法有好几种，比较常用的是这两种：

一种是改改域名的 DNS 记录。但这要求更新程序能连上 DNS 提供商的 API，所以得看你用的 DNS 提供商有没有这个功能。

另一种是在这个域名对应的公共 IP 地址上开个服务器（至少在申请证书的时候得开着）。不过就像咱们之前说的，一个 IP 加一个端口，只能有一个进程在监听。

这也是为什么让 TLS 终止代理同时负责更新证书会很方便。要是让别的程序来更新，可能就得先把 TLS 终止代理停掉，启动更新程序去拿新证书，再把新证书配置到 TLS 终止代理里，最后重新启动它。这可不太好，因为 TLS 终止代理一关，你的应用程序就没法用了。

所以啊，专门用一个 TLS 终止代理来处理 HTTPS，而不是让应用服务器（比如 Uvicorn）直接用 TLS 证书，好处之一就是更新证书的时候，服务能一直开着，不耽误事。






















